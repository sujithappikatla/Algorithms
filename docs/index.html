<h1 id="heap">Heap</h1>
<h2 id="description">Description</h2>
<ul>
<li>Tree based data structure</li>
<li>Complete Binary tree</li>
<li>Most of times can be implemented with arrays</li>
<li>Parent node is always greater/lesser than child nodes</li>
<li>0th index of array always contains smallest/largest element.</li>
</ul>
<hr />
<h2 id="approach">Approach</h2>
<h3 id="push">Push</h3>
<ul>
<li>Insert element at last index of array</li>
<li>while child comes befores parent</li>
<li>swap child and parent</li>
<li>change current child -&gt; parent</li>
<li>parent -&gt; (child-1)/2</li>
</ul>
<h3 id="pop">Pop</h3>
<ul>
<li>Remove element from 0th index of array</li>
<li>Insert last element of array in 0th index, and decrease size of array by 1</li>
<li>parent -&gt; 0, child = value that comes first among child nodes (2<em>parent+1 , 2</em>parent+2)</li>
<li>while child comes before parent</li>
<li>swap child and parent</li>
<li>change parent-&gt; child</li>
<li>child -&gt; value that comes first among child nodes (2<em>parent+1 , 2</em>parent+2)</li>
</ul>
<hr />
<h2 id="complexity">Complexity</h2>
<blockquote>
<p><strong>Time Complexity</strong></p>
<p>Push - O(log(n))</p>
<p>Pop - O(log(n))</p>
<hr />
<p><strong>Space Complexity</strong> - O(n) # Single Source Shortest Path On DAG</p>
</blockquote>
<h2 id="description-1">Description</h2>
<ul>
<li>To find Shortest Distance from source vertex to all other vertices</li>
<li>Faster when compared to Djikstra and Bellman-Ford</li>
<li>Works only For Directed Acyclic Graphs(DAG)</li>
<li>Works for both positive and negative edge weights</li>
<li>Depends on topological ordering</li>
</ul>
<hr />
<h2 id="approach-1">Approach</h2>
<ul>
<li>Intialize <strong>dist</strong> array of size <strong>n</strong> to <strong>INFINITY</strong> and dist[s]=0, where <strong>s</strong> is source vertex</li>
<li>For every vertex <strong>u</strong> in topological order
<ul>
<li>Do following for every <strong>adjacent</strong> vertex <strong>v</strong> of <strong>u</strong></li>
<li>if dist[u] + weight(u,v) &lt; dist[v]
<ul>
<li>dist[v] = dist[u] + weight(u, v)</li>
</ul></li>
</ul></li>
<li>Print <strong>dist</strong> array for minimum distances from source <strong>s</strong></li>
</ul>
<pre><code>Note - Longest Distance from Source vertex can also be found, if we multiply all edges weights with -1 and Apply above algorithm and finally multiply all distances with -1</code></pre>
<hr />
<h2 id="complexity-1">Complexity</h2>
<blockquote>
<p>Time Complexity - O(V+E)</p>
<p>Space Complexity - O(V) # Topological Sorting</p>
</blockquote>
<h2 id="description-2">Description</h2>
<ul>
<li>Linear Ordering of vertices, such that for every directed edge (u, v) -&gt; u comes before V in ordering</li>
<li>Graph needs to be DAG(Directed Acyclic Graph)</li>
</ul>
<hr />
<h2 id="approach-2">Approach</h2>
<ul>
<li>Create Stack to store nodes</li>
<li>Maintain visited array of length <strong>n</strong> nodes, initialized to <strong>false</strong></li>
<li>Iterate all nodes, if node not visited</li>
<li>Call Recursive function to perform following
<ul>
<li>Mark node as visited</li>
<li>For every directed edge going out from this node, if not visited, call recursive function</li>
<li>Push current node to Stack</li>
</ul></li>
<li>Print all nodes in Stack</li>
</ul>
<p><strong><em>Note</em></strong> - A vertex added to stack only when all of its adjacent vertices are in Stack.</p>
<hr />
<h2 id="complexity-analysis">Complexity Analysis</h2>
<blockquote>
<p>Time Complexity - O(V+E)</p>
<p>Space Complexity - O(V)</p>
</blockquote>
